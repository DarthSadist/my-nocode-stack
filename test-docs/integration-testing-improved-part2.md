# Расширенное руководство по интеграционному тестированию стека (Часть 2)

## 5.4. Тестирование комплексных сценариев (продолжение)

#### 5.4.2. Сценарий интерактивного пользовательского взаимодействия

**Тестирование пользовательского сценария с несколькими компонентами:**

```bash
# Скрипт для тестирования пользовательского сценария
cat > /tmp/test-user-interaction-flow.sh << 'EOF'
#!/bin/bash

echo "Тестирование сценария пользовательского взаимодействия..."

# Шаг 1: Имитация пользовательского запроса через webhook
echo "Шаг 1: Отправка пользовательского запроса..."
curl -s -X POST https://n8n.yourdomain.com/webhook/test-user-interaction \
  -H "Content-Type: application/json" \
  -d '{
    "query": "Расскажи о новых технологиях искусственного интеллекта",
    "userId": "test-user-123",
    "timestamp": "'$(date -Iseconds)'"
  }'

# Шаг 2-6: Эти шаги требуют настройки и запуска workflows в n8n и Flowise
echo "Для полного тестирования необходимо настроить следующие компоненты:"
echo "- Webhook в n8n для приема пользовательских запросов"
echo "- Workflow в n8n для обработки запросов и передачи в Flowise"
echo "- Чатфлоу в Flowise для генерации ответов с помощью AI"
echo "- Настройка Redis для хранения истории взаимодействия"
echo "- Интеграция с WordPress для публикации результатов"

echo "Тестирование пользовательского сценария завершено!"
EOF

chmod +x /tmp/test-user-interaction-flow.sh
```

#### 5.4.3. Сценарий автоматического обогащения контента

**Тестирование процесса автоматического обогащения контента:**

1. Создайте новую запись в WordPress с базовым содержимым
2. Настройте n8n для мониторинга новых записей
3. При обнаружении новой записи, извлеките ключевые темы через Flowise
4. Используйте ключевые темы для поиска связанной информации в Qdrant
5. Дополните исходную запись найденной информацией через WordPress API
6. Сохраните метаданные о процессе обогащения в Redis

```bash
# Скрипт для тестирования автоматического обогащения контента
cat > /tmp/test-content-enrichment.sh << 'EOF'
#!/bin/bash

echo "Тестирование сценария автоматического обогащения контента..."

# Шаг 1: Создание записи в WordPress с базовым содержимым
echo "Шаг 1: Создание записи в WordPress..."
TOKEN=$(curl -s -X POST https://wordpress.yourdomain.com/wp-json/jwt-auth/v1/token \
  --data "username=admin&password=your_password" | grep -o '"token":"[^"]*' | sed 's/"token":"//')

if [ -n "$TOKEN" ]; then
  RESPONSE=$(curl -s -X POST https://wordpress.yourdomain.com/wp-json/wp/v2/posts \
    -H "Authorization: Bearer $TOKEN" \
    -H "Content-Type: application/json" \
    -d '{
      "title": "Базовая статья для обогащения",
      "content": "Искусственный интеллект становится все более важным в современном мире. Технологии машинного обучения применяются во многих областях.",
      "status": "publish",
      "meta": {
        "enrichment_status": "pending"
      }
    }')
  
  POST_ID=$(echo $RESPONSE | grep -o '"id":[0-9]*' | sed 's/"id"://')
  
  if [ -n "$POST_ID" ]; then
    echo "Тестовая запись успешно создана в WordPress (ID: $POST_ID)"
    
    # Шаг 2-6: Эти шаги требуют настройки компонентов
    echo "Для завершения теста необходимо настроить следующие компоненты:"
    echo "- Webhook в WordPress для уведомления n8n о новых записях"
    echo "- Workflow в n8n для мониторинга новых записей"
    echo "- Интеграцию с Flowise для извлечения ключевых тем"
    echo "- Поиск в Qdrant по ключевым темам"
    echo "- Обновление WordPress-записи через API"
    echo "- Сохранение метаданных в Redis"
  else
    echo "Не удалось создать тестовую запись в WordPress!"
  fi
else
  echo "Не удалось получить токен аутентификации WordPress!"
fi

echo "Тестирование сценария автоматического обогащения завершено!"
EOF

chmod +x /tmp/test-content-enrichment.sh
```

### 5.5. Тестирование отказоустойчивости интегрированной системы

#### 5.5.1. Тестирование восстановления после сбоя компонента

```bash
# Скрипт для тестирования восстановления системы после сбоя компонента
cat > /tmp/test-component-failure-recovery.sh << 'EOF'
#!/bin/bash

echo "Тестирование восстановления после сбоя компонента..."

# Выбор компонента для тестирования
COMPONENT=${1:-"redis"}
echo "Выбран компонент: $COMPONENT"

# Проверка доступности всех компонентов перед тестом
echo "Проверка исходного состояния системы..."
docker ps --format "{{.Names}}" | grep -E 'n8n|flowise|postgres|redis|qdrant|wordpress|mariadb' | while read container; do
  docker inspect --format '{{.State.Status}}' $container
done

# Функция для проверки интеграций
check_integrations() {
  echo "Проверка интеграций между компонентами..."
  
  # Проверка n8n и PostgreSQL
  docker exec n8n nc -zv postgres 5432 || echo "Ошибка соединения n8n с PostgreSQL"
  
  # Проверка Flowise и Qdrant
  docker exec flowise curl -s http://qdrant:6333/health || echo "Ошибка соединения Flowise с Qdrant"
  
  # Проверка WordPress и MariaDB
  docker exec wordpress mysqladmin -h mariadb -u$MYSQL_USER -p$MYSQL_PASSWORD ping || echo "Ошибка соединения WordPress с MariaDB"
  
  # Проверка n8n и Redis
  docker exec n8n redis-cli -h redis ping || echo "Ошибка соединения n8n с Redis"
}

# Проверка интеграций перед остановкой компонента
check_integrations

# Остановка выбранного компонента
echo "Остановка компонента $COMPONENT..."
docker stop $COMPONENT
echo "Компонент $COMPONENT остановлен"

# Проверка влияния на систему
echo "Проверка состояния системы без компонента $COMPONENT..."
check_integrations

# Перезапуск компонента
echo "Перезапуск компонента $COMPONENT..."
docker start $COMPONENT
echo "Компонент $COMPONENT запущен"

# Ожидание восстановления
echo "Ожидание восстановления компонента..."
sleep 15

# Проверка восстановления интеграций
echo "Проверка восстановления интеграций..."
check_integrations

echo "Тестирование восстановления завершено!"
EOF

chmod +x /tmp/test-component-failure-recovery.sh
```

**Инструкции по использованию скрипта:**
1. Запустите скрипт для тестирования восстановления после сбоя Redis:
   ```
   /tmp/test-component-failure-recovery.sh redis
   ```
2. Повторите тест для других компонентов:
   ```
   /tmp/test-component-failure-recovery.sh postgres
   /tmp/test-component-failure-recovery.sh n8n
   /tmp/test-component-failure-recovery.sh flowise
   /tmp/test-component-failure-recovery.sh qdrant
   ```

#### 5.5.2. Тестирование обработки ошибок в интеграционных потоках

```bash
# Скрипт для тестирования обработки ошибок в интеграционных потоках
cat > /tmp/test-error-handling.sh << 'EOF'
#!/bin/bash

echo "Тестирование обработки ошибок в интеграционных потоках..."

# Тест 1: Ошибка подключения к Qdrant из Flowise
echo "Тест 1: Имитация ошибки подключения к Qdrant..."
# Остановка Qdrant
docker stop qdrant

# Попытка выполнить запрос к Flowise, который должен использовать Qdrant
FLOW_ID=$(curl -s https://flowise.yourdomain.com/api/v1/chatflows | grep -o '"id":"[^"]*' | head -1 | sed 's/"id":"//')
if [ -n "$FLOW_ID" ]; then
  echo "Отправка запроса в Flowise с недоступным Qdrant..."
  curl -s -X POST "https://flowise.yourdomain.com/api/v1/prediction/$FLOW_ID" \
    -H "Content-Type: application/json" \
    -d '{
      "question": "Тестирование обработки ошибок: Qdrant недоступен",
      "overrideConfig": {
        "sessionId": "error-handling-test-1"
      }
    }'
fi

# Восстановление Qdrant
docker start qdrant
sleep 10

# Тест 2: Отправка некорректных данных в API
echo "Тест 2: Отправка некорректных данных в API..."
curl -s -X POST "https://n8n.yourdomain.com/webhook/test-error-handling" \
  -H "Content-Type: application/json" \
  -d '{
    "malformed_data": true,
    "missing_required_fields": true
  }'

# Тест 3: Имитация временной недоступности Redis
echo "Тест 3: Имитация временной недоступности Redis..."
docker stop redis
sleep 5

# Попытка использовать n8n workflow, который зависит от Redis
curl -s -X POST "https://n8n.yourdomain.com/webhook/test-redis-dependency" \
  -H "Content-Type: application/json" \
  -d '{
    "testKey": "testValue",
    "timestamp": "'$(date -Iseconds)'"
  }'

# Восстановление Redis
docker start redis
sleep 5

echo "Тестирование обработки ошибок завершено!"
EOF

chmod +x /tmp/test-error-handling.sh
```

### 5.6. Общие рекомендации по интеграционному тестированию

#### 5.6.1. Подготовка к системному тестированию

1. **Создайте полную тестовую среду**:
   - Настройте все компоненты с тестовыми данными
   - Убедитесь, что все сервисы запущены и доступны
   - Подготовьте скрипты для быстрого восстановления исходного состояния

2. **Документируйте интеграционные точки**:
   - Определите все интерфейсы между компонентами
   - Опишите форматы данных, передаваемых между сервисами
   - Задокументируйте ожидаемое поведение при различных сценариях

3. **Автоматизируйте тестирование**:
   - Создайте скрипты для автоматического выполнения тестов
   - Настройте регулярное выполнение тестов (например, после обновлений)
   - Реализуйте механизмы оповещения о проблемах

#### 5.6.2. Чек-лист для интеграционного тестирования

```markdown
## Чек-лист интеграционного тестирования стека

### Базовые проверки
- [ ] Все контейнеры запущены и стабильны
- [ ] Все сервисы доступны по HTTP/HTTPS
- [ ] Внутренняя сеть функционирует корректно
- [ ] Аутентификация и авторизация работают правильно

### Интеграции между компонентами
- [ ] n8n успешно подключается к PostgreSQL
- [ ] n8n успешно подключается к Redis
- [ ] Flowise успешно подключается к Qdrant
- [ ] WordPress успешно подключается к MariaDB
- [ ] n8n успешно взаимодействует с Flowise API
- [ ] n8n успешно взаимодействует с WordPress API
- [ ] Flowise успешно использует API внешних сервисов

### Потоки данных
- [ ] Данные корректно передаются из n8n в Flowise
- [ ] Данные корректно передаются из WordPress в n8n
- [ ] Данные корректно передаются из Flowise в Qdrant
- [ ] Результаты поиска из Qdrant корректно обрабатываются

### Комплексные сценарии
- [ ] Сценарий многоэтапной обработки данных выполняется успешно
- [ ] Сценарий пользовательского взаимодействия работает корректно
- [ ] Сценарий автоматического обогащения контента функционирует

### Обработка ошибок и восстановление
- [ ] Система корректно обрабатывает недоступность компонентов
- [ ] Система восстанавливается после перезапуска компонентов
- [ ] Транзакции корректно обрабатывают сбои и откаты
- [ ] Логирование ошибок настроено и работает правильно

### Производительность интеграций
- [ ] Время отклика в интеграционных потоках в пределах нормы
- [ ] Система стабильна при параллельном выполнении задач
- [ ] Использование ресурсов (CPU, память) в пределах нормы
```

#### 5.6.3. Рекомендации по оптимизации интеграций

1. **Оптимизация передачи данных**:
   - Минимизируйте объем передаваемых данных между компонентами
   - Используйте пакетную обработку для больших наборов данных
   - Применяйте сжатие данных при необходимости

2. **Кеширование для повышения производительности**:
   - Настройте Redis для кеширования часто используемых данных
   - Используйте локальные кеши в компонентах, где это целесообразно
   - Установите оптимальные TTL для кешированных данных

3. **Асинхронная обработка для сложных потоков**:
   - Используйте очереди сообщений для длительных операций
   - Реализуйте механизмы отложенной обработки через n8n
   - Применяйте паттерн "публикация-подписка" для событийно-ориентированной архитектуры

4. **Мониторинг интеграций**:
   - Настройте Netdata для отслеживания производительности интеграций
   - Создайте дашборды для визуализации ключевых метрик
   - Настройте оповещения о проблемах в интеграционных потоках

### 5.7. Заключение по интеграционному тестированию

Комплексное интеграционное тестирование вашего стека включает не только проверку отдельных компонентов, но и их взаимодействия в различных сценариях. Важно регулярно проводить такое тестирование, особенно после обновлений или изменений в конфигурации.

Описанные выше тесты помогут обеспечить стабильную и надежную работу всей системы, своевременно выявлять проблемы и поддерживать высокое качество сервиса для конечных пользователей.

## 6. Общие рекомендации по тестированию и поддержке стека

### 6.1. Непрерывное тестирование и мониторинг

1. **Регулярное выполнение тестов**:
   - Настройте автоматическое выполнение базовых тестов по расписанию
   - Проводите полное тестирование после каждого значительного обновления
   - Включите тестирование в процессы CI/CD, если они используются

2. **Мониторинг в реальном времени**:
   - Используйте Netdata для непрерывного мониторинга всех компонентов
   - Настройте оповещения о критических событиях и аномалиях
   - Регулярно анализируйте тренды производительности и использования ресурсов

3. **Централизованное журналирование**:
   - Настройте сбор и анализ логов со всех компонентов
   - Внедрите инструменты для поиска и анализа проблем в логах
   - Сохраняйте логи достаточно долго для ретроспективного анализа

### 6.2. Обновление и поддержка компонентов

1. **Управление обновлениями**:
   - Следите за выходом обновлений безопасности для всех компонентов
   - Тестируйте обновления в тестовой среде перед применением в production
   - Документируйте все изменения и процедуры отката при необходимости

2. **Резервное копирование**:
   - Регулярно проверяйте процедуры резервного копирования всех компонентов
   - Тестируйте процесс восстановления из резервных копий
   - Храните резервные копии в нескольких местах для повышения надежности

3. **Управление конфигурацией**:
   - Храните конфигурацию компонентов в системе контроля версий
   - Документируйте все изменения конфигурации и их причины
   - Используйте инструменты управления конфигурацией для автоматизации
