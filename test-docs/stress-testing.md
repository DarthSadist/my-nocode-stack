# Стресс-тестирование системы

## Введение

Данный документ описывает методологию, инструменты и процессы для стресс-тестирования компонентов NoCode Stack. Целью стресс-тестирования является определение пределов производительности системы, выявление узких мест и проверка поведения системы при экстремальных нагрузках.

## Важность стресс-тестирования

Стресс-тестирование позволяет:

1. **Определить пределы масштабируемости** - понять максимальное количество пользователей, запросов или операций, которые система может обрабатывать
2. **Выявить узкие места** - идентифицировать компоненты, которые первыми становятся ограничителями производительности
3. **Проверить отказоустойчивость** - оценить поведение системы при критических нагрузках
4. **Валидировать восстановление** - проверить, как система восстанавливается после отказа из-за перегрузки
5. **Оптимизировать ресурсы** - определить оптимальное распределение ресурсов между компонентами

## Типы стресс-тестирования

### 1. Тестирование предельной нагрузки

Постепенное увеличение нагрузки до тех пор, пока система не достигнет предела своих возможностей:

- Увеличение числа одновременных пользователей
- Увеличение числа одновременных запросов
- Увеличение объема обрабатываемых данных

### 2. Тестирование выносливости (Soak Testing)

Поддержание высокой, но не максимальной нагрузки в течение длительного периода времени:

- Выявление утечек памяти
- Проверка стабильности производительности
- Выявление проблем с кэшированием и управлением ресурсами

### 3. Тестирование пиковой нагрузки (Spike Testing)

Внезапное значительное увеличение нагрузки:

- Проверка поведения системы при резких скачках нагрузки
- Оценка механизмов масштабирования
- Проверка механизмов очередей и буферизации

### 4. Тестирование отказоустойчивости

Намеренное создание сбоев в системе при высокой нагрузке:

- Отключение отдельных компонентов
- Имитация сетевых проблем
- Искусственное ограничение ресурсов

## Инструменты для стресс-тестирования

### Инструменты для генерации нагрузки

| Инструмент | Описание | Основное применение |
|------------|----------|---------------------|
| Apache JMeter | Инструмент для тестирования производительности с открытым исходным кодом | Всесторонннее тестирование производительности веб-приложений |
| Locust | Инструмент для распределенного тестирования нагрузки | Масштабируемое тестирование нагрузки с использованием Python |
| Siege | Утилита для тестирования нагрузки HTTP | Быстрые и простые тесты нагрузки |
| k6 | Современный инструмент для тестирования нагрузки | JavaScript-ориентированное тестирование нагрузки |
| Artillery | Современный инструмент для тестирования нагрузки | Тестирование производительности API и микросервисов |

### Инструменты для мониторинга

| Инструмент | Описание | Основное применение |
|------------|----------|---------------------|
| Prometheus | Система мониторинга с открытым исходным кодом | Сбор метрик производительности |
| Grafana | Платформа для визуализации и аналитики | Создание дашбордов для анализа производительности |
| Netdata | Система мониторинга в реальном времени | Мониторинг системных ресурсов |
| cAdvisor | Мониторинг контейнеров Docker | Анализ производительности контейнеров |
| Telegraf | Агент для сбора метрик | Сбор различных метрик производительности |

## Ключевые метрики для стресс-тестирования

### Метрики производительности

| Метрика | Описание | Целевое значение | Критическое значение |
|---------|----------|------------------|---------------------|
| Время отклика | Время между отправкой запроса и получением ответа | <200 мс | >1000 мс |
| Пропускная способность | Количество запросов, обрабатываемых в секунду | >100 RPS | <50 RPS |
| Latency (задержка) | Время обработки запроса | <100 мс | >500 мс |
| Concurrent Users | Количество одновременных пользователей | >100 | <20 |
| Error Rate | Процент ошибок | <1% | >5% |

### Системные метрики

| Метрика | Описание | Целевое значение | Критическое значение |
|---------|----------|------------------|---------------------|
| CPU Usage | Использование процессора | <70% | >90% |
| Memory Usage | Использование памяти | <80% | >95% |
| Disk I/O | Операции чтения/записи на диск | <80% | >95% |
| Network I/O | Использование сетевой пропускной способности | <60% | >90% |
| Connection Pool | Использование пула соединений | <70% | >90% |

## Процесс стресс-тестирования

### 1. Подготовка к тестированию

- Определение целей и границ тестирования
- Создание тестовой среды
- Подготовка тестовых данных
- Установка инструментов мониторинга
- Определение критериев успеха/неудачи

### 2. Планирование тестовых сценариев

- Разработка пользовательских сценариев
- Определение профилей нагрузки
- Определение метрик для мониторинга
- Планирование длительности и интенсивности тестов

### 3. Выполнение тестов

- Базовое тестирование для определения исходных показателей
- Постепенное увеличение нагрузки
- Мониторинг метрик производительности в реальном времени
- Фиксация поведения системы при различных уровнях нагрузки

### 4. Анализ результатов

- Сбор и консолидация данных
- Анализ метрик и выявление узких мест
- Сравнение с базовыми показателями
- Определение предельной нагрузки и точек отказа

### 5. Формирование рекомендаций

- Разработка рекомендаций по оптимизации
- Приоритизация выявленных проблем
- Планирование улучшений
- Документирование результатов и выводов

## Скрипты для стресс-тестирования

### Скрипт для стресс-тестирования с использованием Siege

```bash
#!/bin/bash
# Скрипт для стресс-тестирования с использованием Siege
# Сохраните как ~/my-nocode-stack/test-scripts/run-stress-test.sh

LOGS_DIR="$HOME/my-nocode-stack/test-logs/stress"
REPORTS_DIR="$HOME/my-nocode-stack/test-reports/stress"

# Создание директорий для логов и отчетов
mkdir -p "$LOGS_DIR"
mkdir -p "$REPORTS_DIR"

# Определение цветов для вывода
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RESET='\033[0m'

# Загрузка переменных окружения
if [ -f "$HOME/my-nocode-stack/.env" ]; then
    source "$HOME/my-nocode-stack/.env"
    DOMAIN_NAME="${DOMAIN_NAME:-example.com}"
else
    echo -e "${RED}Файл .env не найден, используется значение по умолчанию: example.com${RESET}"
    DOMAIN_NAME="example.com"
fi

echo -e "${GREEN}Запуск стресс-тестирования веб-компонентов...${RESET}"

# Проверка наличия Siege
if ! command -v siege &> /dev/null; then
    echo -e "${YELLOW}Siege не установлен. Устанавливаем...${RESET}"
    sudo apt-get update && sudo apt-get install -y siege
fi

# Создание файла с URL для тестирования
URL_FILE="$LOGS_DIR/urls.txt"
cat > $URL_FILE << EOF
http://$DOMAIN_NAME
http://n8n.$DOMAIN_NAME
http://flowise.$DOMAIN_NAME
http://qdrant.$DOMAIN_NAME
EOF

# Функция для запуска тестирования
run_stress_test() {
    local concurrency=$1
    local time=$2
    local description=$3
    
    echo -e "${YELLOW}Запуск теста: $description${RESET}"
    echo -e "Одновременных пользователей: $concurrency"
    echo -e "Продолжительность: $time секунд"
    
    # Имя файла для отчета
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local report_file="$REPORTS_DIR/siege_${concurrency}users_${time}s_${timestamp}.txt"
    
    # Запуск Siege
    siege -c $concurrency -t ${time}S -f $URL_FILE -v -l $report_file
    
    # Анализ результатов
    echo -e "\n${GREEN}Тест завершен. Результаты:${RESET}"
    grep "Availability:" $report_file
    grep "Response time:" $report_file
    grep "Transaction rate:" $report_file
    
    echo -e "\nПодробный отчет сохранен в: $report_file"
}

# Запуск серии тестов с увеличивающейся нагрузкой
echo -e "${GREEN}Запуск серии стресс-тестов с увеличивающейся нагрузкой...${RESET}"

# Базовый тест с низкой нагрузкой
run_stress_test 10 30 "Базовый тест с низкой нагрузкой"

# Тест со средней нагрузкой
run_stress_test 50 60 "Тест со средней нагрузкой"

# Тест с высокой нагрузкой
run_stress_test 100 60 "Тест с высокой нагрузкой"

# Тест с экстремальной нагрузкой
run_stress_test 200 30 "Тест с экстремальной нагрузкой"

# Тест пиковой нагрузки (кратковременный всплеск)
run_stress_test 300 10 "Тест пиковой нагрузки (кратковременный всплеск)"

echo -e "${GREEN}Серия стресс-тестов завершена. Все отчеты сохранены в $REPORTS_DIR${RESET}"
```

### Скрипт для мониторинга системы во время стресс-тестирования

```bash
#!/bin/bash
# Скрипт для мониторинга системы во время стресс-тестирования
# Сохраните как ~/my-nocode-stack/test-scripts/monitor-stress-test.sh

LOGS_DIR="$HOME/my-nocode-stack/test-logs/stress"
INTERVAL=5  # интервал сбора метрик в секундах
DURATION=600  # длительность мониторинга в секундах (10 минут)

# Создание директории для логов
mkdir -p "$LOGS_DIR"

# Определение цветов для вывода
GREEN='\033[0;32m'
RESET='\033[0m'

timestamp=$(date +%Y%m%d_%H%M%S)
CPU_LOG="$LOGS_DIR/cpu_usage_${timestamp}.log"
MEM_LOG="$LOGS_DIR/mem_usage_${timestamp}.log"
DISK_LOG="$LOGS_DIR/disk_io_${timestamp}.log"
NET_LOG="$LOGS_DIR/net_io_${timestamp}.log"
DOCKER_LOG="$LOGS_DIR/docker_stats_${timestamp}.log"

echo -e "${GREEN}Запуск мониторинга системы во время стресс-тестирования...${RESET}"
echo -e "Интервал сбора метрик: $INTERVAL секунд"
echo -e "Продолжительность мониторинга: $DURATION секунд"
echo -e "Логи будут сохранены в $LOGS_DIR"

# Функция для сбора метрик CPU
monitor_cpu() {
    echo "Timestamp,CPU_User,CPU_System,CPU_Idle" > $CPU_LOG
    for ((i=0; i<$DURATION; i+=$INTERVAL)); do
        timestamp=$(date +"%Y-%m-%d %H:%M:%S")
        mpstat 1 1 | grep -A 1 "%usr" | tail -n 1 | awk -v ts="$timestamp" '{print ts","$3","$5","$12}' >> $CPU_LOG
        sleep $INTERVAL
    done
}

# Функция для сбора метрик памяти
monitor_memory() {
    echo "Timestamp,Total,Used,Free,Buffers,Cached" > $MEM_LOG
    for ((i=0; i<$DURATION; i+=$INTERVAL)); do
        timestamp=$(date +"%Y-%m-%d %H:%M:%S")
        free -m | grep Mem: | awk -v ts="$timestamp" '{print ts","$2","$3","$4","$6","$7}' >> $MEM_LOG
        sleep $INTERVAL
    done
}

# Функция для сбора метрик дисковой активности
monitor_disk() {
    echo "Timestamp,Read_IO/s,Write_IO/s,Read_KB/s,Write_KB/s" > $DISK_LOG
    for ((i=0; i<$DURATION; i+=$INTERVAL)); do
        timestamp=$(date +"%Y-%m-%d %H:%M:%S")
        iostat -d -x 1 2 | grep -A 1 Device | tail -n 1 | awk -v ts="$timestamp" '{print ts","$4","$5","$6","$7}' >> $DISK_LOG
        sleep $INTERVAL
    done
}

# Функция для сбора метрик сетевой активности
monitor_network() {
    echo "Timestamp,Received_KB/s,Transmitted_KB/s" > $NET_LOG
    for ((i=0; i<$DURATION; i+=$INTERVAL)); do
        timestamp=$(date +"%Y-%m-%d %H:%M:%S")
        sar -n DEV 1 1 | grep -A 1 "IFACE" | grep -v "IFACE" | grep -v "^$" | awk -v ts="$timestamp" '{print ts","$5/1024","$6/1024}' >> $NET_LOG
        sleep $INTERVAL
    done
}

# Функция для сбора метрик Docker
monitor_docker() {
    echo "Timestamp,Container,CPU%,MEM_Usage,MEM%,NET_IN,NET_OUT" > $DOCKER_LOG
    for ((i=0; i<$DURATION; i+=$INTERVAL)); do
        timestamp=$(date +"%Y-%m-%d %H:%M:%S")
        docker stats --no-stream --format "{{.Name}},{{.CPUPerc}},{{.MemUsage}},{{.MemPerc}},{{.NetIO}}" | \
        awk -v ts="$timestamp" '{print ts","$0}' >> $DOCKER_LOG
        sleep $INTERVAL
    done
}

# Запуск сбора метрик в фоновом режиме
monitor_cpu &
CPU_PID=$!
monitor_memory &
MEM_PID=$!
monitor_disk &
DISK_PID=$!
monitor_network &
NET_PID=$!
monitor_docker &
DOCKER_PID=$!

echo -e "${GREEN}Мониторинг запущен. Сбор данных будет производиться в течение $DURATION секунд...${RESET}"

# Ожидание завершения сбора данных
sleep $DURATION

# Завершение процессов мониторинга
kill $CPU_PID $MEM_PID $DISK_PID $NET_PID $DOCKER_PID

echo -e "${GREEN}Мониторинг завершен. Логи сохранены:${RESET}"
echo -e "CPU: $CPU_LOG"
echo -e "Memory: $MEM_LOG"
echo -e "Disk I/O: $DISK_LOG"
echo -e "Network I/O: $NET_LOG"
echo -e "Docker: $DOCKER_LOG"
```

## Рекомендации по анализу результатов стресс-тестирования

### Анализ времени отклика

1. **Базовое время отклика** - время отклика при низкой нагрузке
2. **Динамика изменения** - как время отклика меняется с увеличением нагрузки
3. **Точки перелома** - уровни нагрузки, при которых происходит резкое увеличение времени отклика
4. **Распределение** - анализ перцентилей времени отклика (90-й, 95-й, 99-й)

### Анализ пропускной способности

1. **Максимальная пропускная способность** - максимальное количество запросов в секунду
2. **Точка насыщения** - уровень нагрузки, при котором пропускная способность перестает расти
3. **Стабильность** - насколько стабильна пропускная способность при различных уровнях нагрузки

### Анализ ошибок

1. **Частота ошибок** - процент ошибок при различных уровнях нагрузки
2. **Типы ошибок** - распределение ошибок по типам (5xx, 4xx, таймауты)
3. **Пороговые значения** - уровни нагрузки, при которых начинают появляться ошибки

### Анализ ресурсов

1. **Утилизация CPU** - как растет загрузка процессора с увеличением нагрузки
2. **Использование памяти** - динамика использования памяти, наличие утечек
3. **Дисковые операции** - интенсивность операций ввода-вывода
4. **Сетевая активность** - объем и интенсивность сетевого трафика

## Интерпретация результатов и типичные проблемы

### Типичные проблемы при стресс-тестировании

| Проблема | Симптомы | Возможные причины | Рекомендации |
|----------|----------|-------------------|--------------|
| Утечка памяти | Постоянный рост использования памяти | Незакрытые ресурсы, циклические ссылки | Профилирование памяти, анализ кода на утечки |
| Блокировка ресурсов | Резкое снижение пропускной способности | Deadlocks, неэффективное управление блокировками | Оптимизация механизмов блокировки, пересмотр архитектуры |
| Исчерпание пула соединений | Ошибки соединения с базой данных | Недостаточный размер пула, незакрытые соединения | Увеличение пула, оптимизация использования соединений |
| Насыщение CPU | 100% загрузка CPU, рост времени отклика | Неоптимизированные алгоритмы, недостаточные ресурсы | Оптимизация кода, масштабирование ресурсов |
| Проблемы с кэшированием | Высокая нагрузка на базу данных | Неэффективное кэширование, частые cache misses | Оптимизация стратегии кэширования |

### Рекомендации по масштабированию

1. **Вертикальное масштабирование**
   - Увеличение ресурсов существующих серверов
   - Оптимизация конфигурации компонентов
   - Улучшение алгоритмов и оптимизация кода

2. **Горизонтальное масштабирование**
   - Увеличение количества инстансов сервисов
   - Балансировка нагрузки между инстансами
   - Разделение на микросервисы

3. **Оптимизация баз данных**
   - Индексирование и оптимизация запросов
   - Шардирование данных
   - Репликация для распределения нагрузки чтения

4. **Оптимизация сетевого взаимодействия**
   - Использование CDN для статических ресурсов
   - Сжатие данных при передаче
   - Оптимизация протоколов взаимодействия

## Заключение

Стресс-тестирование является важной частью комплексного подхода к обеспечению надежности и производительности NoCode Stack. Регулярное проведение стресс-тестирования позволяет выявлять потенциальные проблемы до того, как они проявятся в производственной среде, оптимизировать использование ресурсов и обеспечить стабильную работу системы даже при высоких нагрузках.

Рекомендуется включить стресс-тестирование в регулярный процесс обеспечения качества, особенно перед релизами новых версий и после значительных изменений в архитектуре или конфигурации системы. Сочетание автоматизированного стресс-тестирования с тщательным мониторингом и анализом результатов позволит поддерживать высокий уровень производительности и надежности системы.
